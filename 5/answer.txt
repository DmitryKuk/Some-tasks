Задача под названием "Первый герой" (с одного контеста):

Самолет героев телесериала «Первый герой» потерпел крушение, и они оказались на необитаемом острове. Героям повезло: уцелела карта полетов, которая была у пилотов самолета. По этой карте они смогли определить, какие рейсы пролетают на достаточно близком расстоянии, чтобы их сигнальные костры были замечены. Среди героев оказался профессор Арифметик, которого заинтересовал вопрос: какое математическое ожидание времени ожидания первого пролетающего мимо самолета.
В рамках этой задачи он использовал следующие ограничения:
все авиарейсы независимы;
интервалы вылета одного маршрута постоянны;
все маршруты начинают движения в произвольное время, до того как они потерпели крушение (к сожалению ни одних часов не осталось целых, и даже координат своего местоположения профессор не знает).
Другими словами, если kый авиарейс летает с интервалом tk часов и первый раз после крушения он пролетит мимо через sk часов, то sk — случайная величина равномерно распределенная на полуинтервале [0;   tk).

Формат ввода
Первая строка входных данных содержит единственное число N — количество маршрутов (1 ≤ N ≤ 5). Вторая строка содержит N
целых положительных чисел tk (1 ≤ tk ≤ 50).

Формат вывода
В единственной строке выведите математическое ожидание времени ожидания первого самолета в виде несократимой дроби (в часах).


Решение на питоне (3-м):

# Author: Dmitry Kukovinets (d1021976@gmail.com)

from fractions import Fraction
from functools import *
from itertools import combinations
from operator import add


N = int(input())
times = tuple(sorted([ int(t) for t in input().split(' ') ]))


# Returns fraction
def f(n, d):
	return Fraction(numerator = n, denominator = d)


# Sum of 1/(t_k1 * ... * t_kn), where t_k1..t_kn is each combination of times
def comb_sum(n):
	return reduce(
		add,
		map(lambda c: reduce(lambda x, y: x * Fraction(1, y), c, Fraction(1)),
			combinations(times, n)),
		Fraction(0)
	)


t = times[0]

E = reduce(
	add,
	map(lambda n: f(n * t ** (n + 1), n + 1) * comb_sum(n) * (-1 if n % 2 == 0 else 1),
		range(1, N + 1))
)


if E.denominator == 1:
	print("%s/1" % E.numerator)
else:
	print(E)



Ещё задача (из курса "Дискретные структуры" в университете):
Py1. Решение рекуррентных соотношений третьего порядка

Стоимость задачи: 8 бонусных баллов. При использовании библиотек NumPy/SciPy стоимость понижается до 6 баллов.
Требуется написать программу, которая по рекуррентному соотношению (не более чем) третьего порядка выдаёт формулу общего решения этого соотношения в LaTeX-формате.
На вход программе подаётся строка следующего вида:
коэффициент идентификатор_{индекс} + коэффициент идентификатор_{индекс} + коэффициент идентификатор_{индекс} + коэффициент идентификатор_{индекс} = 0
Некоторые из членов могут отсутствовать. Также могут отсутствовать коэффициенты, равные единице. Идентификатор однобуквенный, переменная в индексе тоже. Примеры корректных входных строк:
15 a_{n} + 8 a_{n-2} - 99 a_{n-3} = 0
8 V_{s-1} + V_{s+2} + V_{s} = 0
Программа должна выдать формулу для общего члена последовательности следующего вида:
$идентификатор_индекс = выражение$
        Здесь выражение — это запись в TeXовской нотации. Например:
$V_s = const_1\cdot 2^s + (const_2 s+const_3)\cdot (-4)^s$
Никаких алгебраических упрощений при получении ответа делать не нужно. Например, не требуется сокращать дроби. Ответ должен быть точным, без округлений.
О том, как решать кубические уравнения, можно прочитать на Википедии.

Её решение (268 строк): https://github.com/DmitryKuk/Discrete-structures/blob/master/Py1.py
Здесь можно посмотреть примеры ответов: https://www.sharelatex.com/project/539c8bf98ec1375f2f8607a7
